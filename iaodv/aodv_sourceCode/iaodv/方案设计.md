##AODV有线无线互联方案
###1 初始化阶段
####1.1 节点初始化
每个节点在启动时需要得知自身类型，IP地址，接口属性与数量，并对各类数据结构进行初始化。IP地址和网关通过脚本初始化或命令配置，节点初始化时维护一张网络设备接口表，并根据该表表项内容确定自身属性（`net_dev_list`）。

- **说明**：根据设备类型初始化各类广播包，刷新表等时间间隔，如不同类型的节点hello包的广播间隔。
- 对于无线节点而言，邻居是频繁变化的，故hello频率应较高，相应的邻居列表更新时间间隔也较短。
- 对于有线节点而言，一旦部署，邻居变化的几率较小，可以间隔较长时间维护邻居可达性，相应的其邻居列表的更新时间也较长。这样可以降低部分网络负载。互连节点在互连网络中较少，可以采用与无线节点一致的方式。（未找到可用的方式）

####1.2 网络环境初始化
从所有可用接口广播hello包，进行邻居发现，维护局部连通性。

####1.3 实现方案
- **设备初始化与维护**：通过脚本配置设备的网络接口，初始化模块时从系统接口列表中获得网络设备的各项参数，并初始化为绑定sock的aodv_dev设备，由模块自维护网络设备列表。设备的节点名称以及默认网络设备为第一个被初始化的网络设备IP及该接口。同时统计接口数量和判断设备类型：MN，ICN，WDN。并维护本节点的IP地址列表`local_ip_list`。
- **局部连通性**：在hello包和邻居信息里添加邻居节点名称和接口字段，同名称不同IP为同一不同接口的hello包。邻居信息提供按名称搜索和按IP搜索功能。
- **各类刷新间隔参数初始化（无）**
根据节点类型确定广播包间隔，刷新操作间隔可以节省部分网络开销，而对于在有线链路上产生的断路而已，则会间接导致链路断开感知不及时，就该方面而言需要权衡一下。

###2 广播与单播
####2.1 三类节点的广播和单播
- **无线节点**（WLN）：只需对唯一的无线接口进行广播与单播。
- **互连节点**（WDN）：
（1）对无线接口进行广播与单播。
（2）需要为每个有线接口复制一份广播数据，如果是本节点产生的或者从无线网口接收到的数据包，则对所有有线接口进行广播，如果是从有线接口接收到的数据包，则对除来源接口外的其他有线接口依次进行广播。单播时只需针对特定接口进行单播即可。
（3）广播时，为了充分利用有线信道，优先从有线接口广播，再从无线接口广播。
- **有线节点**（ICN）：如果是本节点产生的数据包，则依次对所有有线接口进行广播，若是从其他节点接收到的数据包，则对除来源接口外的其他有线接口进行广播。单播时针对特定接口进行数据转发。
（有线接口需要进行排除来源接口的特殊处理是因为同一总线上的所有有线节点在其接收到广播分组时，也都能够接收到同样的数据，故无需再进行广播，以节省带宽，避免广播泛滥，加重网络负载。）

####2.2 实现方案
#####2.2.1 广播
- **参数**：ttl，data，dev，其中ttl为生存期，data为要广播的数据，dev为数据来源接口。
- **dev参数**：对于自产生且需要广播的数据（hello，源rreq等），以dev=NULL标示，遍历网络设备列表，对每个设备发送广播包。对于非自产生的数据，若dev为无线，仍针对所有注册到本节点的网络接口广播数据；若dev为有线，遍历网络设备列表并对除该dev外的接口进行广播。
- **顺序**：在维护设备列表时，为了保证优先广播有线接口，设备插入时，有线设备在队首插入，无线设备在有线设备之后插入。
#####2.2.2 单播
参数为ttl，data，IP，dev，其中ttl为生存期，data为要广播的数据，IP为下一跳地址，dev为数据待发送接口。单播时无论接口为有线或无线，均仅针对指定IP和dev参数进行单播。

###3.邻居维护
####3.1 基本操作
- 周期性广播Hello包以维护局部连通性，维护一张邻居列表并定时刷新。如果一个节点接收到同一个邻居不同接口发送来的hello包，则在邻居列表中维护相应IP的邻居信息，通过邻居名称可识别是否为同一个邻居。
- 接收到来自邻居的Hello包时，仅在邻居列表中维护，不立刻建立邻居路由，而是将建立路由的时机推迟到有数据需要发送时，这样可以保证在有数据需要发送时可以选择最好的链路。
- **Hello包格式**
Type | Neigh Name | Neigh Type | DST IP | DST ID | SRC IP | Hop Count | Lifetime
- **邻居列表条目格式**
Neighbor IP | Neigh Name | Neigh Type | DST ID | in_iface | Lifetime
####3.2 实现细节
- 每个节点周期性地广播Hello包。
- 节点接收到hello包时，按邻居IP查询邻居列表中是否有该邻居，若无则为其建立一条邻居信息条目，否则更新生存期。由邻居名称可以识别唯一邻居，由（邻居名称：IP）可以唯一地识别邻居的某个接口。
- 若在`ALLOW_LOSS * HELLO_INTEVAL`时间内未收到某个邻居的hello包，说明已与该邻居相应接口失去联系，删除对应邻居信息，若路由表中存在邻居路由，则删除。可能由此引起的断路处理在断路模块中说明。
- 接收到hello包时节点仅在邻居列表中维护与邻居的联系，不实际建立路由。当有数据发送时，按图3-1的流程建立邻居路由。
- 图3-1[alt text](https://github.com/Naturekid/aodv-Android/blob/without-ettwcim/3-1.png "图3-1")
####3.3 场景说明
假设A,B间存在两种链路，如图3-2，实线部分为有线，虚线部分为无线。有无线的接口及IP地址不同。

- 图3-2[alt text](https://github.com/Naturekid/aodv-Android/blob/without-ettwcim/3-2.PNG "图3-2")
- B节点在A开始广播Hello包后先后接收到A节点广播的hello包，分别建立两个邻居表项。
- 当B尝试向A发送数据，目的地址为192.168.1.108，无路由时，查询邻居列表发现目的节点为邻居，B判别自身和邻居均为ICN节点，且相应接口为eth0，以192.168.1.108，eth0为网络设备建立路由，然后发送数据。
- 当B尝试向A发送数据，目的地址为192.168.1.8，无路由时，查询邻居列表发现目的节点为邻居，B判别自身和邻居均为ICN节点，且相应接口为adhoc0，尝试寻找更好的链路。以pan-192.168.1.108获得（192.168.1.108，Pan-192.168.1.108，Eth0），判断有线比无线更优，将192.168.1.108作为下一跳，eth0为网络设备建立路由，然后发送数据。

###4 路由发现
####4.1 路由发现
- 当某个节点有数据要发送时，检查其路由表，若有到目的节点的路由，则按照该路由进行发送，否则判断数据包的源与目的是否为当前节点和其邻居，如果是进入邻居路由建立流程。
- 非则发起路由发现过程，即产生RREQ并广播。
- 当中间节点第一次接收到RREQ时，根据RREQ包创建从当前节点到源节点的反向路由，路由条目数据包含目的节点IP（dst），源节点IP（src），目的序列号（`dst_id`），下一跳IP（`next_hop`，发送RREQ的邻居节点），出口接口（`outcome_iface`，RREQ来源接口），接口属性等。
- 若本节点为目的节点或存在到目的节点的路由，产生一个RREP包，沿由RREQ创建的路由发送给源节点，无则继续广播该RREQ包。
- 当中间节点接收到RREP时，将发送者作为正向路径的下一跳建立路由表项，方法与处理RREQ相同，再转发给由RREQ建立的路由的上一跳。
- 当源节点接收到RREP时，建立路由，此后可以进行正常的数据发送。
####4.2 实现方案
#####4.2.1 RREQ处理
- 节点接收到RREQ时，判断该RREQ是否来自已知邻居，未知来源则丢弃。再根据DST_ID判断是否已接收到相同的RREQ，若是则丢弃。
- 查询本节点是否为目的节点或者存在到目的节点的路由，若是，生成RREP并沿RREQ建立的反向路径返回RREP给源节点。
- 若均不是，则从数据包中获取来源IP和来源接口作为下一跳`next_hop`和出口接口`outcom_iface`建立路由。路由条目数据包含目的节点IP（`dst`），源节点IP（`src`），目的序列号（`dst_id`），下一跳IP（`next_hop`，发送RREQ的邻居节点），出口接口（`outcome_iface`，`RREQ`来源接口），接口属性等。
- 图4-1[alt text](https://github.com/Naturekid/aodv-Android/blob/without-ettwcim/4-1.PNG "图4-1")

#####4.2.2 RREP处理
目的节点或者中间节点产生RREP时，从RREQ建立的反向路由中获得将要发送数据的接口号，添加到RREP中，根据已建立路由（下一跳IP，链路，发送接口号outcome_iface）单播给源节点。
当中间节点接收到RREP时，将RREP发送者作为正向路径的下一跳IP，将RREP的来源接口作为出口接口建立路由表项，方法与处理RREQ相同，再转发给由RREQ建立的路由的上一跳。
当源节点接收到RREP时，建立路由，此后可以进行正常的数据发送。
####4.3 场景说明
见图4-2。

- 图4-2[alt text](https://github.com/Naturekid/aodv-Android/blob/without-ettwcim/4-2.PNG "图4-2")

###5 路由表维护
定期更新路由表，删除过期的路由表项，在原有AODV的路由表项数据结构上，增加控制数据包来源接口的字段，该字段以绑定aodv_dev形式存在。

- 路由表项
DST IP | SRC IP | DST ID | Next_hop | Out_iface | lifetime | State

####5.1 实现细节
- 定时对路由表进行刷新以清理已过期或失效的路由。
- 每当有数据流使用该路由时，更新路由条目的生存期。
- 对于用以维护节点的序列号及表明自身路由信息的`g_local_route`默认为手机启动时第一个初始化的设备ip。对于后续启动的设备，不做`g_local_route`处理。但在路由表及内核中均为其建立表项。

###6 链路中断处理
- 当一条存在数据发送的链路因为某种原因（如节点关机，移动，或信号不稳定等原因）而产生中断时，通常表现为链路中的某一处或多处节点不能被其上一跳节点x发现，则该段链路上失效节点的上一跳x可以通过邻居删除而发现该段链路已失效。*此时，节点x首先根据邻居的节点名称判断两个节点间是否其他方式的链路连接，如果有，则修改本地的路由条目关于下一跳和发送接口信息字段，且不做链路中断处理。*如果没有，节点x将产生一个关于失效邻居的RERR包，并根据当前节点路由表中的下一跳为失效节点的路由条目确定受影响链路，(根据路由条目中关于上一跳的信息)将该RERR信息单播给源节点，并从路游表中删除相应路由。
- 接收到RERR的中间节点认为与数据包来源节点的链路对于完整的端到端链路也是失效的，进行类似针对失效节点的处理。根据当前节点路由表中的下一跳为来源节点的路由条目确定受影响链路，将该RERR信息继续往源单播，并删除相应路由。
- 当源节点收到RERR信息时，确定受影响链路，并删除相应路由且不再转发RERR包。然后发起新的路由发现过程以寻找一条代替失效链路的路径。
Type | DST IP | DST ID | SRC IP | DST counts
- 有线节点如何确定hello包和邻居列表刷新间隔，间隔较小浪费带宽，间隔大则可能造成断路通知不及时。根据有线节点较为稳定的特征，倾向于间隔较大。
###7 路由优化
在互联方案中，网络拓扑变化快部分的主要集中在移动自组网部分，而有线节点及互联节点移动性相对较小，网络拓扑相对稳定，故由于节点移动性和节点开启或关闭导致的网络环境变好或变坏也集中在移动自组网部分，路由优化主要针对该部分。
一条存在数据发送的链路上的节点，如果检测到周围有新的邻居出现，向当前节点存在数据发送的链路源节点发送一个网络环境变化通知包（下文称重定向包），由源节点尝试寻找一条可能更优的路由。在向源发送通知包时，需要包括本节点到目的跳数，以及沿途收集有线节点的信息或数量，用以源节点在发现一条新路径时进行对比。
源节点在收到重定向包时，发送具有特殊标志的RREQ包，并设置等待新路径的计时器。该RREQ包即使在路由发现过程中遇到有到目的节点路由的节点时，也不做产生RREP包的返回处理(以区别对待正在发送的链路，未免导致发现新路径失败)。该RREQ包只有到达目的节点时才产生RREP包。其他的路由建立过程与初次路由发现一致。相应的，该RREP包在返回源节点的过程中沿途收集经过节点信息。
如果源节点在等待新路径的计时器过期前接收到RREP包，源节点将比较新路径的跳数和沿途经过的有线节点数目，将跳数较少，经过有线节点数目多的路径作为新的路径发送数据。

**其他数据结构**

- RREQ包格式
type | SRC IP | DST IP | DST ID | hop_counts 
- RREP包格式
type | SRC IP | DST IP | DST ID | hop_counts
